import numpy as np
from _typeshed import Incomplete
from edgeiq import bounding_box as bounding_box
from edgeiq._constants import SupportedPurposes as SupportedPurposes
from edgeiq._production_client import PRODUCTION_CLIENT as PRODUCTION_CLIENT
from edgeiq._utils import draw_text_with_background as draw_text_with_background
from edgeiq.base_service import BaseService as BaseService
from edgeiq.engine_accelerator import Engine as Engine
from edgeiq.exceptions import NoMoreResults as NoMoreResults
from edgeiq.model_config import ModelConfig as ModelConfig
from edgeiq.processing import ObjectDetectionProcessor as ObjectDetectionProcessor
from edgeiq.processing.object_detection.object_detection import PostProcessBatchT as PostProcessBatchT, PostProcessT as PostProcessT, PreProcessBatchT as PreProcessBatchT, PreProcessT as PreProcessT
from edgeiq.tools.results_serialization import to_json_serializable as to_json_serializable
from typing import Any

SUPPORTED_ENGINES: Incomplete

class ObjectDetectionPrediction(bounding_box.BoundingBoxPrediction):
    def __init__(self, box: bounding_box.BoundingBox, confidence: float, label: str, index: int) -> None: ...
    def __eq__(self, other) -> bool: ...
    @property
    def label(self) -> str: ...
    @label.setter
    def label(self, label: str): ...
    @property
    def index(self) -> int: ...

class ObjectDetectionResults:
    def __init__(self, predictions: list[ObjectDetectionPrediction], duration: float, image: np.ndarray | None, **kwargs) -> None: ...
    def __eq__(self, other) -> bool: ...
    @property
    def duration(self) -> float: ...
    @property
    def predictions(self) -> list[ObjectDetectionPrediction]: ...
    @predictions.setter
    def predictions(self, predictions: list[ObjectDetectionPrediction]): ...
    @property
    def image(self) -> np.ndarray | None: ...

RESULT_TYPE: Incomplete

class ObjectDetection(BaseService[ObjectDetectionProcessor]):
    def __init__(self, model_id: str, model_config: ModelConfig | None = None, pre_process: PreProcessT | None = None, pre_process_batch: PreProcessBatchT | None = None, post_process: PostProcessT | None = None, post_process_batch: PostProcessBatchT | None = None) -> None: ...
    def detect_objects(self, image: np.ndarray, confidence_level: float = 0.3, overlap_threshold: float = 0.3) -> ObjectDetectionResults: ...
    def detect_objects_batch(self, images: list[np.ndarray], confidence_level: float = 0.3, overlap_threshold: float = 0.3) -> list[ObjectDetectionResults]: ...
    def publish_analytics(self, results: ObjectDetectionResults, tag: Any = None): ...

class ObjectDetectionAnalytics(BaseService[ObjectDetectionProcessor]):
    annotations: Incomplete
    frame_idx: Incomplete
    deserialized_results: Incomplete
    def __init__(self, annotations: list[str], model_id: str, model_config: ModelConfig | None = None) -> None: ...
    def detect_objects_for_stream(self, stream_idx: int, confidence_level: float = 0.3, overlap_threshold: float = 0.3) -> ObjectDetectionResults: ...
    def detect_objects(self, image: np.ndarray | None, confidence_level: float = 0.3, overlap_threshold: float = 0.3) -> ObjectDetectionResults: ...
    def detect_objects_batch(self, images: list[np.ndarray] | None, confidence_level: float = 0.3, overlap_threshold: float = 0.3) -> list[ObjectDetectionResults]: ...
    def publish_analytics(self, results: ObjectDetectionResults, tag: Any = None): ...

def markup_image(image: np.ndarray, predictions: list[ObjectDetectionPrediction], show_labels: bool = True, show_confidences: bool = True, colors: list[tuple[int, int, int]] | None = None, line_thickness: int = 2, font_size: float = 0.5, font_thickness: int = 2, background_padding: int = 10) -> np.ndarray: ...
def overlay_transparent_boxes(image: np.ndarray, predictions: list[ObjectDetectionPrediction], alpha: float = 0.5, colors: list[tuple[int, int, int]] | None = None, show_labels: bool = False, show_confidences: bool = False): ...
def blur_objects(image: np.ndarray, predictions: list[ObjectDetectionPrediction]) -> np.ndarray: ...
def filter_predictions_by_label(predictions: list[ObjectDetectionPrediction], label_list: list[str]) -> list[ObjectDetectionPrediction]: ...
def filter_predictions_by_area(predictions: list[ObjectDetectionPrediction], min_area_thresh: float) -> list[ObjectDetectionPrediction]: ...
