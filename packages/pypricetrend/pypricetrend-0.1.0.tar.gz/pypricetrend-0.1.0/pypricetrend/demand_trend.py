import pickle
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression


class DemandCurve:
    def __init__(self, orders_df, landed_cost, fulfillment_cost):
        """
        This class generates demand curves for a given product.

        Parameters:
        orders_df (pd.DataFrame): A DataFrame containing the following columns: price, quantity, and date.
        landed_cost (float): The landed cost of the product.
        fulfillment_cost (float): The fulfillment cost of the product.

        """
        self.orders_df = orders_df
        self.landed_cost = landed_cost
        self.fulfillment_cost = fulfillment_cost

        self._generate_demand_curves()
        self.price_elasticity = self._calculate_price_elasticity()

    def _generate_demand_curves(self):
        """
        This function generates demand curves for a given product. The demand curve is generated by fitting a linear model
        to the data and then predicting the number of units sold at each price point. The function then plots the number of
        units sold at each price point along with the trend line. The function also plots the profit at each price point
        along with the trend line.

        Returns:
        None
        """
        self.orders_df["total_sales"] = self.orders_df["price"] * self.orders_df["quantity"]
        self.orders_df["total_order_count"] = self.orders_df["quantity"]
        self.orders_df["normalized_price"] = self.orders_df["price"].apply(DemandCurve.round_price_to_step_size)

        norm_price_ds = self.orders_df.groupby("normalized_price").mean().reset_index()
        count_price = self.orders_df.groupby("normalized_price").count().reset_index()

        self.orders_df["date"] = self.orders_df["date"].dt.date

        average_daily_sales = self.orders_df.groupby("date")["total_order_count"].sum().mean()
        self.average_daily_sales = average_daily_sales

        # self.average_daily_sales = self.orders_df.groupby("date").sum().reset_index().mean()["total_order_count"]

        # add count to norm_priced_ds
        norm_price_ds["count"] = count_price["total_order_count"]

        # remove outliers
        norm_price_ds = norm_price_ds[norm_price_ds["count"] > 3]

        # fit linear model
        self.lin_mdl = DemandCurve._fit_model(norm_price_ds)
        step_size = DemandCurve.get_step_size(norm_price_ds["normalized_price"].min())

        demand, profit, prices = [], [], []
        start_price = norm_price_ds["normalized_price"].min() - (norm_price_ds["normalized_price"].min() / 2)
        max_price = norm_price_ds["normalized_price"].max() * 3

        while True:
            if start_price > max_price:
                break
            price_demand = self.lin_mdl.predict(np.array([[start_price]]))[0]
            price_profit = price_demand * (start_price - self.landed_cost - self.fulfillment_cost)

            if price_demand > 0 and price_profit >= 0:
                demand.append(price_demand)
                prices.append(start_price)
                profit.append(price_profit)

            start_price += step_size

        self.demand = demand
        self.prices = prices
        self.profit = profit

    def predict_demand(self, price):
        """
        This function predicts the demand for a given price.

        Parameters:
        price (float): The price of the product.

        Returns:
        float: The predicted demand for the given price.
        """
        price = DemandCurve.round_price_to_step_size(price)
        return self.lin_mdl.predict(np.array([[price]]))[0]

    def plot_demand_curve(self):
        """
        This function plots the demand curve for the given product.

        Returns:
        None
        """
        plt.figure(figsize=(10, 5))
        plt.plot(
            self.prices,
            self.demand,
            marker="o",
            linestyle="-",
            color="b",
            label="Units Sold",
        )
        plt.plot(self.prices, self.profit, linestyle="--", color="r", label="Trend Line")
        plt.title("Units Sold with Trend Line")
        plt.xlabel("Date")
        plt.ylabel("Units Sold")
        plt.legend()
        plt.grid(True)
        plt.show()

    def _calculate_price_elasticity(self):
        """
        This function calculates the price elasticity of demand for the given product.

        Returns:
        float: The price elasticity of demand.
        """
        price = np.array(self.prices).reshape(-1, 1)
        demand = np.array(self.demand)

        model = LinearRegression()
        model.fit(price, demand)

        price_elasticity = model.coef_[0] * (np.mean(price) / np.mean(demand))
        return price_elasticity

    @staticmethod
    def get_step_size(price):
        """
        This function returns the step size for a given price.

        Parameters:
        price: The price of the product.

        Returns:
        float: The step size.
        """
        if price < 5:
            return 0.05
        elif price < 10:
            return 0.10
        elif price < 25:
            return 0.25
        elif price < 100:
            return 0.5

        return 1.0

    @staticmethod
    def round_price_to_step_size(price):
        """
        This function rounds the price to the nearest step size.

        Parameters:
        price: The price of the product.

        Returns:
        float: The rounded price.
        """
        step_size = DemandCurve.get_step_size(price)
        return round(round(price / step_size, 0) * step_size, 2)

    @staticmethod
    def _fit_model(data):
        """
        This function fits a linear regression model to the data.

        Parameters:
        data (pd.DataFrame): The data to fit the model to.

        Returns:
        LinearRegression: The fitted linear regression model.
        """
        prices = np.array(data["normalized_price"]).reshape(-1, 1)
        units_sold = np.array(data["total_order_count"])

        model = LinearRegression()
        model.fit(prices, units_sold)

        return model
