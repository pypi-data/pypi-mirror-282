# -*- coding: utf-8 -*-

"""
form3publicapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
import dateutil.parser

from form3publicapi.api_helper import APIHelper
from form3publicapi.models.beneficiary_party_3 import BeneficiaryParty3
from form3publicapi.models.debtor_party_2 import DebtorParty2
from form3publicapi.models.settlement import Settlement
from form3publicapi.models.structured_reference import StructuredReference
from form3publicapi.models.ultimate_entity import UltimateEntity


class Attributes23(object):

    """Implementation of the 'Attributes23' model.

    TODO: type model description here.

    Attributes:
        amount (str): Amount of money moved between the instructing agent and
            instructed agent
        beneficiary_party (BeneficiaryParty3): TODO: type description here.
        category_purpose (str): Category purpose in proprietary form.
            Specifies the high level purpose of the instruction. Cannot be
            used at the same time as `category_purpose_coded`.
        category_purpose_coded (str): Category purpose in a coded form.
            Specifies the high level purpose of the instruction. Cannot be
            used at the same time as `category_purpose`.
        clearing_id (str): Unique identifier for organisations collecting
            payments
        currency (str): Currency of the transaction amount. Currency code as
            defined in [ISO
            4217](http://www.iso.org/iso/home/standards/currency_codes.htm)
        debtor_party (DebtorParty2): TODO: type description here.
        end_to_end_reference (str): Unique identification, as assigned by the
            initiating party, to unambiguously identify the transaction. This
            identification is passed on, unchanged, throughout the entire
            end-to-end chain.
        instruction_id (str): Unique identification, as assigned by the
            initiating party to unambiguously identify the transaction. This
            identification is an point-to-point reference and is passed on,
            unchanged, throughout the entire chain. Cannot include leading,
            trailing or internal spaces.
        mandate_amendment_indicator (bool): Indicator notifying whether the
            underlying mandate is amended or not
        mandate_id (str): Original mandate id.
        mandate_signature_date (date): Date on which the direct debit mandate
            has been signed by the debtor.
        numeric_reference (str): Numeric reference field, see scheme specific
            descriptions for usage
        payment_purpose_coded (str): Purpose of the direct debit in a coded
            form
        payment_scheme (str): Clearing infrastructure through which the
            operation instruction is to be processed. Default for given
            organisation ID is used if left empty. Has to be a valid [scheme
            identifier](http://draft-api-docs.form3.tech/api.html#enumerations-
            schemes).
        processing_date (date): Date on which the operation is to be debited
            from the debtor account. Formatted according to ISO 8601 format:
            YYYY-MM-DD.
        reference (str): Payment reference for beneficiary use
        remittance_information (str): Information supplied to enable the
            matching of an entry with the items that the transfer is intended
            to settle, such as commercial invoices in an accounts receivable
            system provided by the debtor for the beneficiary.
        scheme_payment_type (str): The [scheme-specific payment
            type](#enumerations-scheme-payment-types)
        scheme_processing_date (date): Date on which the operation is
            processed by the scheme. Formatted according to ISO 8601 format:
            YYYY-MM-DD. Only used if different from `processing_date`.
        scheme_status (SchemeStatusEnum): This reference is used by the
            receiving party to identify whether the related DDI would have
            been electronic (AUDDIS) or paper‚Äêbased.
        scheme_transaction_id (str): Unique identification, as assigned by the
            first instructing agent, to unambiguously identify the transaction
            that is passed on, unchanged, throughout the entire interbank
            chain.
        settlement (Settlement): Specifies the details on how the settlement
            of the transaction between the instructing agent and the
            instructed agent is completed
        structured_reference (StructuredReference): TODO: type description
            here.
        ultimate_beneficiary (UltimateEntity): TODO: type description here.
        ultimate_debtor (UltimateEntity): TODO: type description here.
        unique_scheme_id (str): The scheme-specific unique transaction ID.
            Populated by the scheme.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "amount": 'amount',
        "beneficiary_party": 'beneficiary_party',
        "category_purpose": 'category_purpose',
        "category_purpose_coded": 'category_purpose_coded',
        "clearing_id": 'clearing_id',
        "currency": 'currency',
        "debtor_party": 'debtor_party',
        "end_to_end_reference": 'end_to_end_reference',
        "instruction_id": 'instruction_id',
        "mandate_amendment_indicator": 'mandate_amendment_indicator',
        "mandate_id": 'mandate_id',
        "mandate_signature_date": 'mandate_signature_date',
        "numeric_reference": 'numeric_reference',
        "payment_purpose_coded": 'payment_purpose_coded',
        "payment_scheme": 'payment_scheme',
        "processing_date": 'processing_date',
        "reference": 'reference',
        "remittance_information": 'remittance_information',
        "scheme_payment_type": 'scheme_payment_type',
        "scheme_processing_date": 'scheme_processing_date',
        "scheme_status": 'scheme_status',
        "scheme_transaction_id": 'scheme_transaction_id',
        "settlement": 'settlement',
        "structured_reference": 'structured_reference',
        "ultimate_beneficiary": 'ultimate_beneficiary',
        "ultimate_debtor": 'ultimate_debtor',
        "unique_scheme_id": 'unique_scheme_id'
    }

    _optionals = [
        'amount',
        'beneficiary_party',
        'category_purpose',
        'category_purpose_coded',
        'clearing_id',
        'currency',
        'debtor_party',
        'end_to_end_reference',
        'instruction_id',
        'mandate_amendment_indicator',
        'mandate_id',
        'mandate_signature_date',
        'numeric_reference',
        'payment_purpose_coded',
        'payment_scheme',
        'processing_date',
        'reference',
        'remittance_information',
        'scheme_payment_type',
        'scheme_processing_date',
        'scheme_status',
        'scheme_transaction_id',
        'settlement',
        'structured_reference',
        'ultimate_beneficiary',
        'ultimate_debtor',
        'unique_scheme_id',
    ]

    def __init__(self,
                 amount=APIHelper.SKIP,
                 beneficiary_party=APIHelper.SKIP,
                 category_purpose=APIHelper.SKIP,
                 category_purpose_coded=APIHelper.SKIP,
                 clearing_id=APIHelper.SKIP,
                 currency=APIHelper.SKIP,
                 debtor_party=APIHelper.SKIP,
                 end_to_end_reference=APIHelper.SKIP,
                 instruction_id=APIHelper.SKIP,
                 mandate_amendment_indicator=APIHelper.SKIP,
                 mandate_id=APIHelper.SKIP,
                 mandate_signature_date=APIHelper.SKIP,
                 numeric_reference=APIHelper.SKIP,
                 payment_purpose_coded=APIHelper.SKIP,
                 payment_scheme=APIHelper.SKIP,
                 processing_date=APIHelper.SKIP,
                 reference=APIHelper.SKIP,
                 remittance_information=APIHelper.SKIP,
                 scheme_payment_type=APIHelper.SKIP,
                 scheme_processing_date=APIHelper.SKIP,
                 scheme_status=APIHelper.SKIP,
                 scheme_transaction_id=APIHelper.SKIP,
                 settlement=APIHelper.SKIP,
                 structured_reference=APIHelper.SKIP,
                 ultimate_beneficiary=APIHelper.SKIP,
                 ultimate_debtor=APIHelper.SKIP,
                 unique_scheme_id=APIHelper.SKIP):
        """Constructor for the Attributes23 class"""

        # Initialize members of the class
        if amount is not APIHelper.SKIP:
            self.amount = amount 
        if beneficiary_party is not APIHelper.SKIP:
            self.beneficiary_party = beneficiary_party 
        if category_purpose is not APIHelper.SKIP:
            self.category_purpose = category_purpose 
        if category_purpose_coded is not APIHelper.SKIP:
            self.category_purpose_coded = category_purpose_coded 
        if clearing_id is not APIHelper.SKIP:
            self.clearing_id = clearing_id 
        if currency is not APIHelper.SKIP:
            self.currency = currency 
        if debtor_party is not APIHelper.SKIP:
            self.debtor_party = debtor_party 
        if end_to_end_reference is not APIHelper.SKIP:
            self.end_to_end_reference = end_to_end_reference 
        if instruction_id is not APIHelper.SKIP:
            self.instruction_id = instruction_id 
        if mandate_amendment_indicator is not APIHelper.SKIP:
            self.mandate_amendment_indicator = mandate_amendment_indicator 
        if mandate_id is not APIHelper.SKIP:
            self.mandate_id = mandate_id 
        if mandate_signature_date is not APIHelper.SKIP:
            self.mandate_signature_date = mandate_signature_date 
        if numeric_reference is not APIHelper.SKIP:
            self.numeric_reference = numeric_reference 
        if payment_purpose_coded is not APIHelper.SKIP:
            self.payment_purpose_coded = payment_purpose_coded 
        if payment_scheme is not APIHelper.SKIP:
            self.payment_scheme = payment_scheme 
        if processing_date is not APIHelper.SKIP:
            self.processing_date = processing_date 
        if reference is not APIHelper.SKIP:
            self.reference = reference 
        if remittance_information is not APIHelper.SKIP:
            self.remittance_information = remittance_information 
        if scheme_payment_type is not APIHelper.SKIP:
            self.scheme_payment_type = scheme_payment_type 
        if scheme_processing_date is not APIHelper.SKIP:
            self.scheme_processing_date = scheme_processing_date 
        if scheme_status is not APIHelper.SKIP:
            self.scheme_status = scheme_status 
        if scheme_transaction_id is not APIHelper.SKIP:
            self.scheme_transaction_id = scheme_transaction_id 
        if settlement is not APIHelper.SKIP:
            self.settlement = settlement 
        if structured_reference is not APIHelper.SKIP:
            self.structured_reference = structured_reference 
        if ultimate_beneficiary is not APIHelper.SKIP:
            self.ultimate_beneficiary = ultimate_beneficiary 
        if ultimate_debtor is not APIHelper.SKIP:
            self.ultimate_debtor = ultimate_debtor 
        if unique_scheme_id is not APIHelper.SKIP:
            self.unique_scheme_id = unique_scheme_id 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if dictionary is None:
            return None

        # Extract variables from the dictionary
        amount = dictionary.get("amount") if dictionary.get("amount") else APIHelper.SKIP
        beneficiary_party = BeneficiaryParty3.from_dictionary(dictionary.get('beneficiary_party')) if 'beneficiary_party' in dictionary.keys() else APIHelper.SKIP
        category_purpose = dictionary.get("category_purpose") if dictionary.get("category_purpose") else APIHelper.SKIP
        category_purpose_coded = dictionary.get("category_purpose_coded") if dictionary.get("category_purpose_coded") else APIHelper.SKIP
        clearing_id = dictionary.get("clearing_id") if dictionary.get("clearing_id") else APIHelper.SKIP
        currency = dictionary.get("currency") if dictionary.get("currency") else APIHelper.SKIP
        debtor_party = DebtorParty2.from_dictionary(dictionary.get('debtor_party')) if 'debtor_party' in dictionary.keys() else APIHelper.SKIP
        end_to_end_reference = dictionary.get("end_to_end_reference") if dictionary.get("end_to_end_reference") else APIHelper.SKIP
        instruction_id = dictionary.get("instruction_id") if dictionary.get("instruction_id") else APIHelper.SKIP
        mandate_amendment_indicator = dictionary.get("mandate_amendment_indicator") if "mandate_amendment_indicator" in dictionary.keys() else APIHelper.SKIP
        mandate_id = dictionary.get("mandate_id") if dictionary.get("mandate_id") else APIHelper.SKIP
        mandate_signature_date = dateutil.parser.parse(dictionary.get('mandate_signature_date')).date() if dictionary.get('mandate_signature_date') else APIHelper.SKIP
        numeric_reference = dictionary.get("numeric_reference") if dictionary.get("numeric_reference") else APIHelper.SKIP
        payment_purpose_coded = dictionary.get("payment_purpose_coded") if dictionary.get("payment_purpose_coded") else APIHelper.SKIP
        payment_scheme = dictionary.get("payment_scheme") if dictionary.get("payment_scheme") else APIHelper.SKIP
        processing_date = dateutil.parser.parse(dictionary.get('processing_date')).date() if dictionary.get('processing_date') else APIHelper.SKIP
        reference = dictionary.get("reference") if dictionary.get("reference") else APIHelper.SKIP
        remittance_information = dictionary.get("remittance_information") if dictionary.get("remittance_information") else APIHelper.SKIP
        scheme_payment_type = dictionary.get("scheme_payment_type") if dictionary.get("scheme_payment_type") else APIHelper.SKIP
        scheme_processing_date = dateutil.parser.parse(dictionary.get('scheme_processing_date')).date() if dictionary.get('scheme_processing_date') else APIHelper.SKIP
        scheme_status = dictionary.get("scheme_status") if dictionary.get("scheme_status") else APIHelper.SKIP
        scheme_transaction_id = dictionary.get("scheme_transaction_id") if dictionary.get("scheme_transaction_id") else APIHelper.SKIP
        settlement = Settlement.from_dictionary(dictionary.get('settlement')) if 'settlement' in dictionary.keys() else APIHelper.SKIP
        structured_reference = StructuredReference.from_dictionary(dictionary.get('structured_reference')) if 'structured_reference' in dictionary.keys() else APIHelper.SKIP
        ultimate_beneficiary = UltimateEntity.from_dictionary(dictionary.get('ultimate_beneficiary')) if 'ultimate_beneficiary' in dictionary.keys() else APIHelper.SKIP
        ultimate_debtor = UltimateEntity.from_dictionary(dictionary.get('ultimate_debtor')) if 'ultimate_debtor' in dictionary.keys() else APIHelper.SKIP
        unique_scheme_id = dictionary.get("unique_scheme_id") if dictionary.get("unique_scheme_id") else APIHelper.SKIP
        # Return an object of this model
        return cls(amount,
                   beneficiary_party,
                   category_purpose,
                   category_purpose_coded,
                   clearing_id,
                   currency,
                   debtor_party,
                   end_to_end_reference,
                   instruction_id,
                   mandate_amendment_indicator,
                   mandate_id,
                   mandate_signature_date,
                   numeric_reference,
                   payment_purpose_coded,
                   payment_scheme,
                   processing_date,
                   reference,
                   remittance_information,
                   scheme_payment_type,
                   scheme_processing_date,
                   scheme_status,
                   scheme_transaction_id,
                   settlement,
                   structured_reference,
                   ultimate_beneficiary,
                   ultimate_debtor,
                   unique_scheme_id)
