# coding: utf-8

"""
    AIForged API

    Integration with AI Forged system  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: support@aiforged.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class WorkItemApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def work_item_create(self, **kwargs):  # noqa: E501
        """Create Workflow for Document / Shred for Backward compatibility  # noqa: E501

        This operation creates a work item for verification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_create(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: Roles to use if user not specified. Optional
        :param str x_api_version:
        :param int doc_id: The document ID
        :param int shred_id: Shred ID for shred work items. Optional
        :param str comment: Comment on the work item. Optional
        :param Method2 method: Work item assignment method. Optional
        :param Action3 action:
        :param str graceperiod: Timespan before work items gets escalated. Optional
        :param int to_group_id:
        :param str to_user_id: A Specific user ID to assign to. Optional
        :param Reason8 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_create_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_create_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_create_with_http_info(self, **kwargs):  # noqa: E501
        """Create Workflow for Document / Shred for Backward compatibility  # noqa: E501

        This operation creates a work item for verification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_create_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] body: Roles to use if user not specified. Optional
        :param str x_api_version:
        :param int doc_id: The document ID
        :param int shred_id: Shred ID for shred work items. Optional
        :param str comment: Comment on the work item. Optional
        :param Method2 method: Work item assignment method. Optional
        :param Action3 action:
        :param str graceperiod: Timespan before work items gets escalated. Optional
        :param int to_group_id:
        :param str to_user_id: A Specific user ID to assign to. Optional
        :param Reason8 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version', 'doc_id', 'shred_id', 'comment', 'method', 'action', 'graceperiod', 'to_group_id', 'to_user_id', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_create" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'to_group_id' in params:
            query_params.append(('toGroupId', params['to_group_id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Create', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_create_ex(self, **kwargs):  # noqa: E501
        """CreateEx Workflow for Document / Shred  # noqa: E501

        This operation creates a work item for verification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_create_ex(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AIForgedDALGroupRoleType] body: Roles to use if user not specified. Optional
        :param str x_api_version:
        :param int doc_id: The document ID
        :param int shred_id: Shred ID for shred work items. Optional
        :param str comment: Comment on the work item. Optional
        :param Method3 method: Work item assignment method. Optional
        :param Action4 action:
        :param str graceperiod: Timespan before work items gets escalated. Optional
        :param int to_group_id:
        :param str to_user_id: A Specific user ID to assign to. Optional
        :param Reason9 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_create_ex_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_create_ex_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_create_ex_with_http_info(self, **kwargs):  # noqa: E501
        """CreateEx Workflow for Document / Shred  # noqa: E501

        This operation creates a work item for verification  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_create_ex_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AIForgedDALGroupRoleType] body: Roles to use if user not specified. Optional
        :param str x_api_version:
        :param int doc_id: The document ID
        :param int shred_id: Shred ID for shred work items. Optional
        :param str comment: Comment on the work item. Optional
        :param Method3 method: Work item assignment method. Optional
        :param Action4 action:
        :param str graceperiod: Timespan before work items gets escalated. Optional
        :param int to_group_id:
        :param str to_user_id: A Specific user ID to assign to. Optional
        :param Reason9 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version', 'doc_id', 'shred_id', 'comment', 'method', 'action', 'graceperiod', 'to_group_id', 'to_user_id', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_create_ex" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'to_group_id' in params:
            query_params.append(('toGroupId', params['to_group_id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/CreateEx', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_delete(self, **kwargs):  # noqa: E501
        """Delete work item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param Reason7 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete work item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param Reason7 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Delete', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsWorkItemViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_escelate(self, **kwargs):  # noqa: E501
        """Escelate to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_escelate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param AIForgedDALWorkItemMethod method:
        :param str comment:
        :param int to_group_id:
        :param str to_user_id:
        :param str graceperiod:
        :param Reason1 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_escelate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_escelate_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_escelate_with_http_info(self, **kwargs):  # noqa: E501
        """Escelate to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_escelate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param AIForgedDALWorkItemMethod method:
        :param str comment:
        :param int to_group_id:
        :param str to_user_id:
        :param str graceperiod:
        :param Reason1 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'method', 'comment', 'to_group_id', 'to_user_id', 'graceperiod', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_escelate" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'to_group_id' in params:
            query_params.append(('toGroupId', params['to_group_id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Escelate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_expire(self, **kwargs):  # noqa: E501
        """Expire WorkItems  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_expire(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type10 type:
        :param Action2 action:
        :param Status5 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param Reason reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_expire_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_expire_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_expire_with_http_info(self, **kwargs):  # noqa: E501
        """Expire WorkItems  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_expire_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type10 type:
        :param Action2 action:
        :param Status5 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param Reason reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'from_date', 'to_date', 'type', 'action', 'status', 'doc_id', 'shred_id', 'comment', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_expire" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('fromDate', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('toDate', params['to_date']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Expire', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_finalize(self, **kwargs):  # noqa: E501
        """Finalize Workflow for Document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_finalize(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param DocStatus2 doc_status:
        :param Reason10 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_finalize_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_finalize_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_finalize_with_http_info(self, **kwargs):  # noqa: E501
        """Finalize Workflow for Document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_finalize_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param DocStatus2 doc_status:
        :param Reason10 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc_id', 'doc_status', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_finalize" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'doc_status' in params:
            query_params.append(('docStatus', params['doc_status']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Finalize', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get(self, **kwargs):  # noqa: E501
        """Get WorkItems  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type9 type:
        :param Action1 action:
        :param Status4 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param int page_no:
        :param int page_size:
        :param SortField4 sort_field:
        :param SortDirection8 sort_direction:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get WorkItems  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type9 type:
        :param Action1 action:
        :param Status4 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param int page_no:
        :param int page_size:
        :param SortField4 sort_field:
        :param SortDirection8 sort_direction:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'from_date', 'to_date', 'type', 'action', 'status', 'doc_id', 'shred_id', 'comment', 'page_no', 'page_size', 'sort_field', 'sort_direction', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('fromDate', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('toDate', params['to_date']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'page_no' in params:
            query_params.append(('pageNo', params['page_no']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'sort_field' in params:
            query_params.append(('sortField', params['sort_field']))  # noqa: E501
        if 'sort_direction' in params:
            query_params.append(('sortDirection', params['sort_direction']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get_by_id(self, **kwargs):  # noqa: E501
        """Get WorkItem By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_by_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_by_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_by_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_by_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get WorkItem By Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_by_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get_by_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/GetById', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsWorkItemViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get_count(self, **kwargs):  # noqa: E501
        """Get WorkItems Count  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type8 type:
        :param Action action:
        :param Status3 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_count_with_http_info(self, **kwargs):  # noqa: E501
        """Get WorkItems Count  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param Type8 type:
        :param Action action:
        :param Status3 status:
        :param int doc_id:
        :param int shred_id:
        :param str comment:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'from_date', 'to_date', 'type', 'action', 'status', 'doc_id', 'shred_id', 'comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('fromDate', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('toDate', params['to_date']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/GetCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get_heatmap(self, **kwargs):  # noqa: E501
        """Get WorkItems Heatmap  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_heatmap(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkFlowSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_heatmap_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_heatmap_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_heatmap_with_http_info(self, **kwargs):  # noqa: E501
        """Get WorkItems Heatmap  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_heatmap_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param int project_id:
        :param datetime from_date:
        :param datetime to_date:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkFlowSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'from_date', 'to_date', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get_heatmap" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('fromDate', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('toDate', params['to_date']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/GetHeatmap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkFlowSummary]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get_summary(self, **kwargs):  # noqa: E501
        """Get WorkItems Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param datetime from_date:
        :param datetime to_date:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkFlowSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get WorkItems Summary  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id:
        :param datetime from_date:
        :param datetime to_date:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkFlowSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'from_date', 'to_date', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'from_date' in params:
            query_params.append(('fromDate', params['from_date']))  # noqa: E501
        if 'to_date' in params:
            query_params.append(('toDate', params['to_date']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/GetSummary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkFlowSummary]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_get_work_queue(self, **kwargs):  # noqa: E501
        """Get document work queue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_work_queue(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int stpd_id: Service id
        :param Usage5 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentsSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_get_work_queue_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_get_work_queue_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_get_work_queue_with_http_info(self, **kwargs):  # noqa: E501
        """Get document work queue  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_get_work_queue_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int stpd_id: Service id
        :param Usage5 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentsSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'stpd_id', 'usage', 'statuses', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_get_work_queue" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/GetWorkQueue', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentsSummary]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_rebuild(self, **kwargs):  # noqa: E501
        """Rebuild workitems and execute custom code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_rebuild(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param Method4 method:
        :param str graceperiod:
        :param bool is_publish:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_rebuild_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_rebuild_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_rebuild_with_http_info(self, **kwargs):  # noqa: E501
        """Rebuild workitems and execute custom code  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_rebuild_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param Method4 method:
        :param str graceperiod:
        :param bool is_publish:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc_id', 'method', 'graceperiod', 'is_publish', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_rebuild" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'is_publish' in params:
            query_params.append(('isPublish', params['is_publish']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Rebuild', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_reject(self, **kwargs):  # noqa: E501
        """Reject work item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_reject(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param Method method:
        :param int to_group_id:
        :param str to_user_id:
        :param str comment:
        :param str graceperiod:
        :param MasterDocStatus master_doc_status:
        :param DocStatus1 doc_status:
        :param Reason4 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_reject_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_reject_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_reject_with_http_info(self, **kwargs):  # noqa: E501
        """Reject work item  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_reject_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param Method method:
        :param int to_group_id:
        :param str to_user_id:
        :param str comment:
        :param str graceperiod:
        :param MasterDocStatus master_doc_status:
        :param DocStatus1 doc_status:
        :param Reason4 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'method', 'to_group_id', 'to_user_id', 'comment', 'graceperiod', 'master_doc_status', 'doc_status', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_reject" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'to_group_id' in params:
            query_params.append(('toGroupId', params['to_group_id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'master_doc_status' in params:
            query_params.append(('masterDocStatus', params['master_doc_status']))  # noqa: E501
        if 'doc_status' in params:
            query_params.append(('docStatus', params['doc_status']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Reject', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_reject_shred(self, **kwargs):  # noqa: E501
        """Reject work items for a shred  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_reject_shred(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param int shred_id:
        :param Method1 method:
        :param int to_group_id:
        :param str to_user_id:
        :param str comment:
        :param str graceperiod:
        :param Reason5 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_reject_shred_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_reject_shred_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_reject_shred_with_http_info(self, **kwargs):  # noqa: E501
        """Reject work items for a shred  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_reject_shred_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id:
        :param int shred_id:
        :param Method1 method:
        :param int to_group_id:
        :param str to_user_id:
        :param str comment:
        :param str graceperiod:
        :param Reason5 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc_id', 'shred_id', 'method', 'to_group_id', 'to_user_id', 'comment', 'graceperiod', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_reject_shred" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'shred_id' in params:
            query_params.append(('shredId', params['shred_id']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'to_group_id' in params:
            query_params.append(('toGroupId', params['to_group_id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'graceperiod' in params:
            query_params.append(('graceperiod', params['graceperiod']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/RejectShred', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_set_status(self, **kwargs):  # noqa: E501
        """Update status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_set_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param AIForgedDALWorkItemStatus status:
        :param Reason6 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_set_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_set_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_set_status_with_http_info(self, **kwargs):  # noqa: E501
        """Update status  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_set_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param AIForgedDALWorkItemStatus status:
        :param Reason6 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'status', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_set_status" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/SetStatus', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_transfer(self, **kwargs):  # noqa: E501
        """Escelate to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_transfer(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param str to_user_id:
        :param str comment:
        :param Reason2 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_transfer_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_transfer_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_transfer_with_http_info(self, **kwargs):  # noqa: E501
        """Escelate to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_transfer_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param str to_user_id:
        :param str comment:
        :param Reason2 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: AIForgedViewModelsWorkItemViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'to_user_id', 'comment', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_transfer" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/Transfer', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsWorkItemViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def work_item_transfer_open(self, **kwargs):  # noqa: E501
        """Transfer all open to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_transfer_open(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_user:
        :param str to_user_id:
        :param int project_id:
        :param str comment:
        :param Reason3 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.work_item_transfer_open_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.work_item_transfer_open_with_http_info(**kwargs)  # noqa: E501
            return data

    def work_item_transfer_open_with_http_info(self, **kwargs):  # noqa: E501
        """Transfer all open to another user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.work_item_transfer_open_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str from_user:
        :param str to_user_id:
        :param int project_id:
        :param str comment:
        :param Reason3 reason:
        :param int reason_lookup:
        :param int reason_record:
        :param str reason_code:
        :param str reason_description:
        :param str reason_comment:
        :param str x_api_version:
        :return: list[AIForgedViewModelsWorkItemViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['from_user', 'to_user_id', 'project_id', 'comment', 'reason', 'reason_lookup', 'reason_record', 'reason_code', 'reason_description', 'reason_comment', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method work_item_transfer_open" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_user' in params:
            query_params.append(('fromUser', params['from_user']))  # noqa: E501
        if 'to_user_id' in params:
            query_params.append(('toUserId', params['to_user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'reason' in params:
            query_params.append(('reason', params['reason']))  # noqa: E501
        if 'reason_lookup' in params:
            query_params.append(('reasonLookup', params['reason_lookup']))  # noqa: E501
        if 'reason_record' in params:
            query_params.append(('reasonRecord', params['reason_record']))  # noqa: E501
        if 'reason_code' in params:
            query_params.append(('reasonCode', params['reason_code']))  # noqa: E501
        if 'reason_description' in params:
            query_params.append(('reasonDescription', params['reason_description']))  # noqa: E501
        if 'reason_comment' in params:
            query_params.append(('reasonComment', params['reason_comment']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/WorkItem/TransferOpen', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsWorkItemViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
