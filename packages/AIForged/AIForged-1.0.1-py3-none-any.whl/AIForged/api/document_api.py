# coding: utf-8

"""
    AIForged API

    Integration with AI Forged system  # noqa: E501

    OpenAPI spec version: 2.0
    Contact: support@aiforged.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DocumentApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def document_bulk_class_change(self, **kwargs):  # noqa: E501
        """Bulk change document classes by status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_class_change(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int from_class_id:
        :param int to_class_id:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_bulk_class_change_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_bulk_class_change_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_bulk_class_change_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk change document classes by status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_class_change_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int from_class_id:
        :param int to_class_id:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'stpd_id_from', 'status_from', 'usage_from', 'from_class_id', 'to_class_id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_bulk_class_change" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id_from' in params:
            query_params.append(('stpdIdFrom', params['stpd_id_from']))  # noqa: E501
        if 'status_from' in params:
            query_params.append(('statusFrom', params['status_from']))  # noqa: E501
        if 'usage_from' in params:
            query_params.append(('usageFrom', params['usage_from']))  # noqa: E501
        if 'from_class_id' in params:
            query_params.append(('fromClassId', params['from_class_id']))  # noqa: E501
        if 'to_class_id' in params:
            query_params.append(('toClassId', params['to_class_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/BulkClassChange', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_bulk_copy(self, **kwargs):  # noqa: E501
        """Bulk Copy document by status and usage to another service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_copy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_from_id:
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int project_to_id:
        :param int stpd_id_to:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param bool include_all_data:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_bulk_copy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_bulk_copy_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_bulk_copy_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk Copy document by status and usage to another service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_copy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_from_id:
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int project_to_id:
        :param int stpd_id_to:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param bool include_all_data:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_from_id', 'stpd_id_from', 'status_from', 'usage_from', 'project_to_id', 'stpd_id_to', 'status_to', 'usage_to', 'include_all_data', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_bulk_copy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_from_id' in params:
            query_params.append(('projectFromId', params['project_from_id']))  # noqa: E501
        if 'stpd_id_from' in params:
            query_params.append(('stpdIdFrom', params['stpd_id_from']))  # noqa: E501
        if 'status_from' in params:
            query_params.append(('statusFrom', params['status_from']))  # noqa: E501
        if 'usage_from' in params:
            query_params.append(('usageFrom', params['usage_from']))  # noqa: E501
        if 'project_to_id' in params:
            query_params.append(('projectToId', params['project_to_id']))  # noqa: E501
        if 'stpd_id_to' in params:
            query_params.append(('stpdIdTo', params['stpd_id_to']))  # noqa: E501
        if 'status_to' in params:
            query_params.append(('statusTo', params['status_to']))  # noqa: E501
        if 'usage_to' in params:
            query_params.append(('usageTo', params['usage_to']))  # noqa: E501
        if 'include_all_data' in params:
            query_params.append(('includeAllData', params['include_all_data']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/BulkCopy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_bulk_move(self, **kwargs):  # noqa: E501
        """Bulk Mode document by status and usage to another service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_move(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_from_id:
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int project_to_id:
        :param int stpd_id_to:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_bulk_move_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_bulk_move_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_bulk_move_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk Mode document by status and usage to another service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_move_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_from_id:
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param int project_to_id:
        :param int stpd_id_to:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_from_id', 'stpd_id_from', 'status_from', 'usage_from', 'project_to_id', 'stpd_id_to', 'status_to', 'usage_to', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_bulk_move" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_from_id' in params:
            query_params.append(('projectFromId', params['project_from_id']))  # noqa: E501
        if 'stpd_id_from' in params:
            query_params.append(('stpdIdFrom', params['stpd_id_from']))  # noqa: E501
        if 'status_from' in params:
            query_params.append(('statusFrom', params['status_from']))  # noqa: E501
        if 'usage_from' in params:
            query_params.append(('usageFrom', params['usage_from']))  # noqa: E501
        if 'project_to_id' in params:
            query_params.append(('projectToId', params['project_to_id']))  # noqa: E501
        if 'stpd_id_to' in params:
            query_params.append(('stpdIdTo', params['stpd_id_to']))  # noqa: E501
        if 'status_to' in params:
            query_params.append(('statusTo', params['status_to']))  # noqa: E501
        if 'usage_to' in params:
            query_params.append(('usageTo', params['usage_to']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/BulkMove', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_bulk_update(self, **kwargs):  # noqa: E501
        """Bulk update document by status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_update(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_bulk_update_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_bulk_update_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_bulk_update_with_http_info(self, **kwargs):  # noqa: E501
        """Bulk update document by status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_bulk_update_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int stpd_id_from:
        :param AIForgedDALDocumentStatus status_from:
        :param AIForgedDALUsageType usage_from:
        :param AIForgedDALDocumentStatus status_to:
        :param AIForgedDALUsageType usage_to:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'stpd_id_from', 'status_from', 'usage_from', 'status_to', 'usage_to', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_bulk_update" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id_from' in params:
            query_params.append(('stpdIdFrom', params['stpd_id_from']))  # noqa: E501
        if 'status_from' in params:
            query_params.append(('statusFrom', params['status_from']))  # noqa: E501
        if 'usage_from' in params:
            query_params.append(('usageFrom', params['usage_from']))  # noqa: E501
        if 'status_to' in params:
            query_params.append(('statusTo', params['status_to']))  # noqa: E501
        if 'usage_to' in params:
            query_params.append(('usageTo', params['usage_to']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/BulkUpdate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_change_field_page_index(self, **kwargs):  # noqa: E501
        """Move fields to another page  # noqa: E501

        This operation moves fields from one page to another in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_change_field_page_index(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int from_page_index: The index of the page where the fields are created
        :param int to_page_index: The index of the page where the fields should move to
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_change_field_page_index_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_change_field_page_index_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_change_field_page_index_with_http_info(self, **kwargs):  # noqa: E501
        """Move fields to another page  # noqa: E501

        This operation moves fields from one page to another in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_change_field_page_index_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int from_page_index: The index of the page where the fields are created
        :param int to_page_index: The index of the page where the fields should move to
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'from_page_index', 'to_page_index', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_change_field_page_index" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'from_page_index' in params:
            query_params.append(('fromPageIndex', params['from_page_index']))  # noqa: E501
        if 'to_page_index' in params:
            query_params.append(('toPageIndex', params['to_page_index']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/ChangeFieldPageIndex', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_classify(self, **kwargs):  # noqa: E501
        """Upload and classify a document  # noqa: E501

        This operation uploads and classifies a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_classify(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int master_id: The parent document ID
        :param str comment: Comment to add to the document
        :param str external_id: Related or external document ID
        :param str result: Result data to add to the document
        :param str result_id: The result ID
        :param int result_index: The result index. Optional
        :param str guid: A Guid ID
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_classify_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_classify_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_classify_with_http_info(self, **kwargs):  # noqa: E501
        """Upload and classify a document  # noqa: E501

        This operation uploads and classifies a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_classify_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int master_id: The parent document ID
        :param str comment: Comment to add to the document
        :param str external_id: Related or external document ID
        :param str result: Result data to add to the document
        :param str result_id: The result ID
        :param int result_index: The result index. Optional
        :param str guid: A Guid ID
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'x_api_version', 'stpd_id', 'project_id', 'master_id', 'comment', 'external_id', 'result', 'result_id', 'result_index', 'guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_classify" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'master_id' in params:
            query_params.append(('masterId', params['master_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'guid' in params:
            query_params.append(('guid', params['guid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Classify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_clone(self, **kwargs):  # noqa: E501
        """Clone a document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_clone(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id: Document Id to Clone
        :param str filename:
        :param int project_id:
        :param int service_id:
        :param int class_id:
        :param int master_id:
        :param bool recursive:
        :param bool parameters:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_clone_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_clone_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_clone_with_http_info(self, **kwargs):  # noqa: E501
        """Clone a document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_clone_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id: Document Id to Clone
        :param str filename:
        :param int project_id:
        :param int service_id:
        :param int class_id:
        :param int master_id:
        :param bool recursive:
        :param bool parameters:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc_id', 'filename', 'project_id', 'service_id', 'class_id', 'master_id', 'recursive', 'parameters', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_clone" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'service_id' in params:
            query_params.append(('serviceId', params['service_id']))  # noqa: E501
        if 'class_id' in params:
            query_params.append(('classId', params['class_id']))  # noqa: E501
        if 'master_id' in params:
            query_params.append(('masterId', params['master_id']))  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'parameters' in params:
            query_params.append(('parameters', params['parameters']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Clone', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_clone_for_training(self, **kwargs):  # noqa: E501
        """Clone a processed document for training  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_clone_for_training(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id: Document Id to copy
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_clone_for_training_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_clone_for_training_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_clone_for_training_with_http_info(self, **kwargs):  # noqa: E501
        """Clone a processed document for training  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_clone_for_training_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc_id: Document Id to copy
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc_id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_clone_for_training" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/CloneForTraining', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_copy(self, **kwargs):  # noqa: E501
        """Copy a document to another project/service and supply a new status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_copy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Destination project
        :param int stpd_id: Destination service
        :param AIForgedDALDocumentStatus status: New status
        :param AIForgedDALUsageType usage: New usage
        :param bool include_all_data: Include all image date
        :param list[int] doc_ids: List of socument Ids to copy
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_copy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_copy_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_copy_with_http_info(self, **kwargs):  # noqa: E501
        """Copy a document to another project/service and supply a new status and usage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_copy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Destination project
        :param int stpd_id: Destination service
        :param AIForgedDALDocumentStatus status: New status
        :param AIForgedDALUsageType usage: New usage
        :param bool include_all_data: Include all image date
        :param list[int] doc_ids: List of socument Ids to copy
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'stpd_id', 'status', 'usage', 'include_all_data', 'doc_ids', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_copy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'include_all_data' in params:
            query_params.append(('includeAllData', params['include_all_data']))  # noqa: E501
        if 'doc_ids' in params:
            query_params.append(('docIds', params['doc_ids']))  # noqa: E501
            collection_formats['docIds'] = 'multi'  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_delete(self, **kwargs):  # noqa: E501
        """Delete a document by ID  # noqa: E501

        This operation marks a document for deletion  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID of the document to delete
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Delete a document by ID  # noqa: E501

        This operation marks a document for deletion  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID of the document to delete
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Delete', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_delete_blob(self, **kwargs):  # noqa: E501
        """Delete a document blob  # noqa: E501

        This operation deletes a document blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_blob(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The blob ID
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_delete_blob_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_delete_blob_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_delete_blob_with_http_info(self, **kwargs):  # noqa: E501
        """Delete a document blob  # noqa: E501

        This operation deletes a document blob  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_blob_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The blob ID
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_delete_blob" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/DeleteBlob', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_delete_fields_on_page(self, **kwargs):  # noqa: E501
        """Delete fields on a page  # noqa: E501

        This operation deletes fields on a page of a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_fields_on_page(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int page_index: The page index
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_delete_fields_on_page_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_delete_fields_on_page_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_delete_fields_on_page_with_http_info(self, **kwargs):  # noqa: E501
        """Delete fields on a page  # noqa: E501

        This operation deletes fields on a page of a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_fields_on_page_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int page_index: The page index
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page_index', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_delete_fields_on_page" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'page_index' in params:
            query_params.append(('pageIndex', params['page_index']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/DeleteFieldsOnPage', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_delete_multi(self, **kwargs):  # noqa: E501
        """Delete multiple documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_multi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] ids: The document Ids to delete
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_delete_multi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_delete_multi_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_delete_multi_with_http_info(self, **kwargs):  # noqa: E501
        """Delete multiple documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_multi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] ids: The document Ids to delete
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ids', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_delete_multi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ids' in params:
            query_params.append(('Ids', params['ids']))  # noqa: E501
            collection_formats['Ids'] = 'multi'  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/DeleteMulti', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_delete_pages(self, body, **kwargs):  # noqa: E501
        """Delete pages from a document  # noqa: E501

        This operation deletes pages in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_pages(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] body: List of page indexes (required)
        :param str x_api_version:
        :param int id: The document ID
        :param AIForgedDALUsageType child_usage: The child document usage type
        :param AIForgedDALDocumentStatus child_status: The status of the child document
        :param AIForgedDALOperationOption child_delete_options: Delete options
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_delete_pages_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.document_delete_pages_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def document_delete_pages_with_http_info(self, body, **kwargs):  # noqa: E501
        """Delete pages from a document  # noqa: E501

        This operation deletes pages in a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_delete_pages_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] body: List of page indexes (required)
        :param str x_api_version:
        :param int id: The document ID
        :param AIForgedDALUsageType child_usage: The child document usage type
        :param AIForgedDALDocumentStatus child_status: The status of the child document
        :param AIForgedDALOperationOption child_delete_options: Delete options
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version', 'id', 'child_usage', 'child_status', 'child_delete_options']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_delete_pages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `document_delete_pages`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'child_usage' in params:
            query_params.append(('childUsage', params['child_usage']))  # noqa: E501
        if 'child_status' in params:
            query_params.append(('childStatus', params['child_status']))  # noqa: E501
        if 'child_delete_options' in params:
            query_params.append(('childDeleteOptions', params['child_delete_options']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/DeletePages', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentDataViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_extract_and_verify(self, **kwargs):  # noqa: E501
        """Upload and extract information for verification  # noqa: E501

        This operation uploads a document and extracts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_extract_and_verify(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int master_id: The parent document ID
        :param str comment: Comments to add to the document
        :param str external_id: Related or external document ID
        :param str result: Result data to add to the document
        :param str result_id: The result ID
        :param int result_index: The result index. Optional
        :param str guid: A Guid ID
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_extract_and_verify_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_extract_and_verify_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_extract_and_verify_with_http_info(self, **kwargs):  # noqa: E501
        """Upload and extract information for verification  # noqa: E501

        This operation uploads a document and extracts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_extract_and_verify_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int master_id: The parent document ID
        :param str comment: Comments to add to the document
        :param str external_id: Related or external document ID
        :param str result: Result data to add to the document
        :param str result_id: The result ID
        :param int result_index: The result index. Optional
        :param str guid: A Guid ID
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'x_api_version', 'stpd_id', 'project_id', 'master_id', 'comment', 'external_id', 'result', 'result_id', 'result_index', 'guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_extract_and_verify" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'master_id' in params:
            query_params.append(('masterId', params['master_id']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'guid' in params:
            query_params.append(('guid', params['guid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/ExtractAndVerify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_find_latest_child(self, **kwargs):  # noqa: E501
        """Find latest child document to assist with verification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_find_latest_child(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param AIForgedDALUsageType usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str filename:
        :param str classname:
        :param int masterid:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_find_latest_child_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_find_latest_child_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_find_latest_child_with_http_info(self, **kwargs):  # noqa: E501
        """Find latest child document to assist with verification  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_find_latest_child_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param AIForgedDALUsageType usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str filename:
        :param str classname:
        :param int masterid:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'stpd_id', 'usage', 'statuses', 'filename', 'classname', 'masterid', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_find_latest_child" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'classname' in params:
            query_params.append(('classname', params['classname']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/FindLatestChild', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_fix_page_verification_index(self, **kwargs):  # noqa: E501
        """Fix page parameter index  # noqa: E501

        This operation fixes page verification indexes of a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_fix_page_verification_index(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_fix_page_verification_index_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_fix_page_verification_index_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_fix_page_verification_index_with_http_info(self, **kwargs):  # noqa: E501
        """Fix page parameter index  # noqa: E501

        This operation fixes page verification indexes of a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_fix_page_verification_index_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_fix_page_verification_index" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/FixPageVerificationIndex', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_blob(self, **kwargs):  # noqa: E501
        """Get the data blob for a document id by image type  # noqa: E501

        This operation gets the blob storage where the document data is stored  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_blob(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User id that owns the document
        :param int id: Blob id
        :param list[object] types: The blob types. Optional
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_blob_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_blob_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_blob_with_http_info(self, **kwargs):  # noqa: E501
        """Get the data blob for a document id by image type  # noqa: E501

        This operation gets the blob storage where the document data is stored  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_blob_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: User id that owns the document
        :param int id: Blob id
        :param list[object] types: The blob types. Optional
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'types', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_blob" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'id' in params:
            query_params.append(('Id', params['id']))  # noqa: E501
        if 'types' in params:
            query_params.append(('types', params['types']))  # noqa: E501
            collection_formats['types'] = 'multi'  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetBlob', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_blob_by_id(self, **kwargs):  # noqa: E501
        """Get blob by blob ID  # noqa: E501

        This operation gets the blob storage associated with the ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_blob_by_id(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The blob ID
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_blob_by_id_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_blob_by_id_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_blob_by_id_with_http_info(self, **kwargs):  # noqa: E501
        """Get blob by blob ID  # noqa: E501

        This operation gets the blob storage associated with the ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_blob_by_id_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The blob ID
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_blob_by_id" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetBlobById', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_classification(self, **kwargs):  # noqa: E501
        """Get a document classification  # noqa: E501

        This operation gets the document classification/category  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_classification(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int doc_id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsClassesViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_classification_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_classification_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_classification_with_http_info(self, **kwargs):  # noqa: E501
        """Get a document classification  # noqa: E501

        This operation gets the document classification/category  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_classification_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int stpd_id: The service ID
        :param int project_id: The project ID
        :param int doc_id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsClassesViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['stpd_id', 'project_id', 'doc_id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_classification" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'doc_id' in params:
            query_params.append(('docId', params['doc_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetClassification', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsClassesViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_data(self, **kwargs):  # noqa: E501
        """Get document images  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_data(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param list[object] types:
        :param str content_type:
        :param str text:
        :param int blobid:
        :param int pageindex:
        :param int images_count:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentDataViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_data_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_data_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_data_with_http_info(self, **kwargs):  # noqa: E501
        """Get document images  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_data_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id:
        :param list[object] types:
        :param str content_type:
        :param str text:
        :param int blobid:
        :param int pageindex:
        :param int images_count:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentDataViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'types', 'content_type', 'text', 'blobid', 'pageindex', 'images_count', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_data" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('Id', params['id']))  # noqa: E501
        if 'types' in params:
            query_params.append(('types', params['types']))  # noqa: E501
            collection_formats['types'] = 'multi'  # noqa: E501
        if 'content_type' in params:
            query_params.append(('contentType', params['content_type']))  # noqa: E501
        if 'text' in params:
            query_params.append(('text', params['text']))  # noqa: E501
        if 'blobid' in params:
            query_params.append(('blobid', params['blobid']))  # noqa: E501
        if 'pageindex' in params:
            query_params.append(('pageindex', params['pageindex']))  # noqa: E501
        if 'images_count' in params:
            query_params.append(('imagesCount', params['images_count']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetData', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentDataViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_document(self, **kwargs):  # noqa: E501
        """Get a document by ID  # noqa: E501

        This operation gets document info for a document ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_document(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_document_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_document_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_document_with_http_info(self, **kwargs):  # noqa: E501
        """Get a document by ID  # noqa: E501

        This operation gets document info for a document ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_document_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_document" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_ex_summary(self, **kwargs):  # noqa: E501
        """Get a summary of documents for analytics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_ex_summary(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param Usage2 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str classname:
        :param int masterid:
        :param str interval:
        :param bool get_labelled_stats:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentsSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_ex_summary_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_ex_summary_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_ex_summary_with_http_info(self, **kwargs):  # noqa: E501
        """Get a summary of documents for analytics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_ex_summary_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param Usage2 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str classname:
        :param int masterid:
        :param str interval:
        :param bool get_labelled_stats:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentsSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'stpd_id', 'usage', 'statuses', 'classname', 'masterid', 'interval', 'get_labelled_stats', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_ex_summary" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if 'classname' in params:
            query_params.append(('classname', params['classname']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'get_labelled_stats' in params:
            query_params.append(('getLabelledStats', params['get_labelled_stats']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetExtendedSummary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentsSummary]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_extended(self, **kwargs):  # noqa: E501
        """Find documnets by using structured search criteria. The results can be paged  # noqa: E501

        This operation gets documents that match the search crieria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_extended(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: Owner of the document
        :param int project_id: The project Id
        :param int stpd_id: The service id
        :param Usage usage: The folder or usage. Optional
        :param list[AIForgedDALDocumentStatus] statuses: List of statuses. Optional
        :param str classname: A class name filter. Optional
        :param str filename: Filename filter. Optional
        :param str filetype: File type filter. Optional
        :param datetime start: Start date range for documents. Optional
        :param datetime end: End date range for documents. Optional
        :param int masterid: Master or parent of the document. Optional
        :param list[object] includeparamdefcategories: Include gategories. Optional
        :param int page_no: Page number. Optional
        :param int page_size: Size of a page. Optional
        :param SortField sort_field: Sort by field. Optional
        :param SortDirection4 sort_direction: Sort direction based on the sortfield. Optional
        :param str comment: Filter for comments. Optional
        :param str result: Filter for results. Optional
        :param str result_id: Filter for a result id. Optional
        :param int result_index: Filter for result index. Optional
        :param str external_id: Filter for external ids. Optional
        :param str doc_guid: Filter for doc guids. Optional
        :param int class_id: Filter for class ID. Optional
        :param int id: Filter for document ID. Optional
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_extended_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_extended_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_extended_with_http_info(self, **kwargs):  # noqa: E501
        """Find documnets by using structured search criteria. The results can be paged  # noqa: E501

        This operation gets documents that match the search crieria  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_extended_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: Owner of the document
        :param int project_id: The project Id
        :param int stpd_id: The service id
        :param Usage usage: The folder or usage. Optional
        :param list[AIForgedDALDocumentStatus] statuses: List of statuses. Optional
        :param str classname: A class name filter. Optional
        :param str filename: Filename filter. Optional
        :param str filetype: File type filter. Optional
        :param datetime start: Start date range for documents. Optional
        :param datetime end: End date range for documents. Optional
        :param int masterid: Master or parent of the document. Optional
        :param list[object] includeparamdefcategories: Include gategories. Optional
        :param int page_no: Page number. Optional
        :param int page_size: Size of a page. Optional
        :param SortField sort_field: Sort by field. Optional
        :param SortDirection4 sort_direction: Sort direction based on the sortfield. Optional
        :param str comment: Filter for comments. Optional
        :param str result: Filter for results. Optional
        :param str result_id: Filter for a result id. Optional
        :param int result_index: Filter for result index. Optional
        :param str external_id: Filter for external ids. Optional
        :param str doc_guid: Filter for doc guids. Optional
        :param int class_id: Filter for class ID. Optional
        :param int id: Filter for document ID. Optional
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'stpd_id', 'usage', 'statuses', 'classname', 'filename', 'filetype', 'start', 'end', 'masterid', 'includeparamdefcategories', 'page_no', 'page_size', 'sort_field', 'sort_direction', 'comment', 'result', 'result_id', 'result_index', 'external_id', 'doc_guid', 'class_id', 'id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_extended" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if 'classname' in params:
            query_params.append(('classname', params['classname']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'filetype' in params:
            query_params.append(('filetype', params['filetype']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501
        if 'includeparamdefcategories' in params:
            query_params.append(('includeparamdefcategories', params['includeparamdefcategories']))  # noqa: E501
            collection_formats['includeparamdefcategories'] = 'multi'  # noqa: E501
        if 'page_no' in params:
            query_params.append(('pageNo', params['page_no']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'sort_field' in params:
            query_params.append(('sortField', params['sort_field']))  # noqa: E501
        if 'sort_direction' in params:
            query_params.append(('sortDirection', params['sort_direction']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'doc_guid' in params:
            query_params.append(('docGuid', params['doc_guid']))  # noqa: E501
        if 'class_id' in params:
            query_params.append(('classId', params['class_id']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetExtended', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_extended_count(self, **kwargs):  # noqa: E501
        """Find documnets count by using structured search criteria This is used to detemine paging  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_extended_count(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param Usage1 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str classname:
        :param str filename:
        :param str filetype:
        :param datetime start:
        :param datetime end:
        :param int masterid:
        :param str comment:
        :param str result:
        :param str result_id:
        :param int result_index:
        :param str external_id:
        :param str doc_guid:
        :param int id:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_extended_count_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_extended_count_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_extended_count_with_http_info(self, **kwargs):  # noqa: E501
        """Find documnets count by using structured search criteria This is used to detemine paging  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_extended_count_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user id
        :param int project_id: The project id
        :param int stpd_id: Service id
        :param Usage1 usage:
        :param list[AIForgedDALDocumentStatus] statuses:
        :param str classname:
        :param str filename:
        :param str filetype:
        :param datetime start:
        :param datetime end:
        :param int masterid:
        :param str comment:
        :param str result:
        :param str result_id:
        :param int result_index:
        :param str external_id:
        :param str doc_guid:
        :param int id:
        :param str x_api_version:
        :return: int
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'stpd_id', 'usage', 'statuses', 'classname', 'filename', 'filetype', 'start', 'end', 'masterid', 'comment', 'result', 'result_id', 'result_index', 'external_id', 'doc_guid', 'id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_extended_count" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if 'classname' in params:
            query_params.append(('classname', params['classname']))  # noqa: E501
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501
        if 'filetype' in params:
            query_params.append(('filetype', params['filetype']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'doc_guid' in params:
            query_params.append(('docGuid', params['doc_guid']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetExtendedCount', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='int',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_hierarchy(self, **kwargs):  # noqa: E501
        """Get a document and its related documents  # noqa: E501

        This operation gets the document hierarchy for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_hierarchy(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_hierarchy_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_hierarchy_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_hierarchy_with_http_info(self, **kwargs):  # noqa: E501
        """Get a document and its related documents  # noqa: E501

        This operation gets the document hierarchy for a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_hierarchy_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_hierarchy" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetHierarchy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_previews(self, **kwargs):  # noqa: E501
        """Get preview documents and images for a service  # noqa: E501

        This operation gets the preview images of documents in a service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_previews(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user ID of the owner of the service
        :param int project_id: The project ID
        :param int stpd_id: The service ID. Optional
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_previews_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_previews_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_previews_with_http_info(self, **kwargs):  # noqa: E501
        """Get preview documents and images for a service  # noqa: E501

        This operation gets the preview images of documents in a service  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_previews_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user_id: The user ID of the owner of the service
        :param int project_id: The project ID
        :param int stpd_id: The service ID. Optional
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'project_id', 'stpd_id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_previews" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetPreviews', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_root(self, **kwargs):  # noqa: E501
        """Get a topmost root document by ID  # noqa: E501

        This operation gets document info for a document ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_root(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_root_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_root_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_root_with_http_info(self, **kwargs):  # noqa: E501
        """Get a topmost root document by ID  # noqa: E501

        This operation gets document info for a document ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_root_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_root" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetRoot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_system_document(self, **kwargs):  # noqa: E501
        """Get system document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_system_document(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename:
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_system_document_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_system_document_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_system_document_with_http_info(self, **kwargs):  # noqa: E501
        """Get system document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_system_document_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filename:
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filename', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_system_document" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in params:
            query_params.append(('filename', params['filename']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetSystemDocument', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentDataViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_system_documents(self, **kwargs):  # noqa: E501
        """Get system documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_system_documents(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: Filename pattern
        :param str filetype: Optional: File type / extention
        :param str contenttype: Optional: Content type
        :param list[AIForgedDALDocumentStatus] statuses: Optional: statuses
        :param int master_id: Optional: master id
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentDataViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_system_documents_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_system_documents_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_system_documents_with_http_info(self, **kwargs):  # noqa: E501
        """Get system documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_system_documents_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str pattern: Filename pattern
        :param str filetype: Optional: File type / extention
        :param str contenttype: Optional: Content type
        :param list[AIForgedDALDocumentStatus] statuses: Optional: statuses
        :param int master_id: Optional: master id
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentDataViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pattern', 'filetype', 'contenttype', 'statuses', 'master_id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_system_documents" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'pattern' in params:
            query_params.append(('pattern', params['pattern']))  # noqa: E501
        if 'filetype' in params:
            query_params.append(('filetype', params['filetype']))  # noqa: E501
        if 'contenttype' in params:
            query_params.append(('contenttype', params['contenttype']))  # noqa: E501
        if 'statuses' in params:
            query_params.append(('statuses', params['statuses']))  # noqa: E501
            collection_formats['statuses'] = 'multi'  # noqa: E501
        if 'master_id' in params:
            query_params.append(('masterId', params['master_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetSystemDocuments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentDataViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_get_training_report(self, **kwargs):  # noqa: E501
        """Get Training Report  # noqa: E501

        This operation gets the training report associated with the document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_training_report(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_get_training_report_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_get_training_report_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_get_training_report_with_http_info(self, **kwargs):  # noqa: E501
        """Get Training Report  # noqa: E501

        This operation gets the training report associated with the document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_get_training_report_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_get_training_report" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/GetTrainingReport', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_merge_to_pdf_for_category(self, **kwargs):  # noqa: E501
        """Merge the provided image documents into a single PDF document for the specified category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_merge_to_pdf_for_category(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int service_id: The service id
        :param int master_doc_id: The master document id of the images
        :param list[int] docs_to_merge_ids: The list of the image document ids to be merged into the PDF
        :param int class_id: The class id
        :param str merg_to_pdf_page_split: Merge document/page split expression
        :param bool merge_group_into_single_category: Merge all categories into single PDF
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_merge_to_pdf_for_category_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_merge_to_pdf_for_category_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_merge_to_pdf_for_category_with_http_info(self, **kwargs):  # noqa: E501
        """Merge the provided image documents into a single PDF document for the specified category  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_merge_to_pdf_for_category_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int service_id: The service id
        :param int master_doc_id: The master document id of the images
        :param list[int] docs_to_merge_ids: The list of the image document ids to be merged into the PDF
        :param int class_id: The class id
        :param str merg_to_pdf_page_split: Merge document/page split expression
        :param bool merge_group_into_single_category: Merge all categories into single PDF
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentDataViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'service_id', 'master_doc_id', 'docs_to_merge_ids', 'class_id', 'merg_to_pdf_page_split', 'merge_group_into_single_category', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_merge_to_pdf_for_category" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'service_id' in params:
            query_params.append(('serviceId', params['service_id']))  # noqa: E501
        if 'master_doc_id' in params:
            query_params.append(('masterDocId', params['master_doc_id']))  # noqa: E501
        if 'docs_to_merge_ids' in params:
            query_params.append(('docsToMergeIds', params['docs_to_merge_ids']))  # noqa: E501
            collection_formats['docsToMergeIds'] = 'multi'  # noqa: E501
        if 'class_id' in params:
            query_params.append(('classId', params['class_id']))  # noqa: E501
        if 'merg_to_pdf_page_split' in params:
            query_params.append(('mergToPdfPageSplit', params['merg_to_pdf_page_split']))  # noqa: E501
        if 'merge_group_into_single_category' in params:
            query_params.append(('mergeGroupIntoSingleCategory', params['merge_group_into_single_category']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/MergeToPdfForCategory', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentDataViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_move(self, **kwargs):  # noqa: E501
        """Move a document to another project and service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_move(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int to_stpd_id:
        :param AIForgedDALDocumentStatus to_status:
        :param AIForgedDALUsageType to_usage:
        :param list[int] doc_ids:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_move_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_move_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_move_with_http_info(self, **kwargs):  # noqa: E501
        """Move a document to another project and service  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_move_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project id
        :param int to_stpd_id:
        :param AIForgedDALDocumentStatus to_status:
        :param AIForgedDALUsageType to_usage:
        :param list[int] doc_ids:
        :param str x_api_version:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'to_stpd_id', 'to_status', 'to_usage', 'doc_ids', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_move" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'to_stpd_id' in params:
            query_params.append(('toStpdId', params['to_stpd_id']))  # noqa: E501
        if 'to_status' in params:
            query_params.append(('toStatus', params['to_status']))  # noqa: E501
        if 'to_usage' in params:
            query_params.append(('toUsage', params['to_usage']))  # noqa: E501
        if 'doc_ids' in params:
            query_params.append(('docIds', params['doc_ids']))  # noqa: E501
            collection_formats['docIds'] = 'multi'  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_set_field_page_verification_index(self, **kwargs):  # noqa: E501
        """Change field verification index  # noqa: E501

        This operation changes the verification index of a field  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_set_field_page_verification_index(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int from_page_index: The index of the page where the fields are created
        :param int to_page_index: The index of the page where the fields should move to
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_set_field_page_verification_index_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_set_field_page_verification_index_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_set_field_page_verification_index_with_http_info(self, **kwargs):  # noqa: E501
        """Change field verification index  # noqa: E501

        This operation changes the verification index of a field  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_set_field_page_verification_index_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The document ID
        :param int from_page_index: The index of the page where the fields are created
        :param int to_page_index: The index of the page where the fields should move to
        :param str x_api_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'from_page_index', 'to_page_index', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_set_field_page_verification_index" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'from_page_index' in params:
            query_params.append(('fromPageIndex', params['from_page_index']))  # noqa: E501
        if 'to_page_index' in params:
            query_params.append(('toPageIndex', params['to_page_index']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/SetFieldPageVerificationIndex', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_store(self, body, **kwargs):  # noqa: E501
        """Store structured doument and containing data blob  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_store(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AIForgedViewModelsDocumentViewModel] body: (required)
        :param str x_api_version:
        :param int stpd_id: Service id
        :param str user_id: The user id
        :param int project_id: The project id
        :param int masterid:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_store_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.document_store_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def document_store_with_http_info(self, body, **kwargs):  # noqa: E501
        """Store structured doument and containing data blob  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_store_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[AIForgedViewModelsDocumentViewModel] body: (required)
        :param str x_api_version:
        :param int stpd_id: Service id
        :param str user_id: The user id
        :param int project_id: The project id
        :param int masterid:
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version', 'stpd_id', 'user_id', 'project_id', 'masterid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `document_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Store', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_un_delete(self, **kwargs):  # noqa: E501
        """Undelete a document by id  # noqa: E501

        This operation removes the deleted state from a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_un_delete(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID of the document to undelete
        :param AIForgedDALDocumentStatus newstatus: The new status after undelete
        :param Usagefilter usagefilter: Only update documents for a specific usage
        :param bool recursive: Recursively undelete
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_un_delete_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_un_delete_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_un_delete_with_http_info(self, **kwargs):  # noqa: E501
        """Undelete a document by id  # noqa: E501

        This operation removes the deleted state from a document  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_un_delete_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The ID of the document to undelete
        :param AIForgedDALDocumentStatus newstatus: The new status after undelete
        :param Usagefilter usagefilter: Only update documents for a specific usage
        :param bool recursive: Recursively undelete
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'newstatus', 'usagefilter', 'recursive', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_un_delete" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'newstatus' in params:
            query_params.append(('newstatus', params['newstatus']))  # noqa: E501
        if 'usagefilter' in params:
            query_params.append(('usagefilter', params['usagefilter']))  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/UnDelete', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_update(self, body, **kwargs):  # noqa: E501
        """Update a document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_update(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AIForgedViewModelsDocumentViewModel body: The document to update (required)
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_update_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.document_update_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def document_update_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update a document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_update_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AIForgedViewModelsDocumentViewModel body: The document to update (required)
        :param str x_api_version:
        :return: AIForgedViewModelsDocumentViewModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `document_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Update', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AIForgedViewModelsDocumentViewModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_update_blob(self, body, **kwargs):  # noqa: E501
        """Update a blob  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_update_blob(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AIForgedViewModelsDocumentDataViewModel body: The blob data to update (required)
        :param str x_api_version:
        :param str user_id: Owner user id
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_update_blob_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.document_update_blob_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def document_update_blob_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update a blob  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_update_blob_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AIForgedViewModelsDocumentDataViewModel body: The blob data to update (required)
        :param str x_api_version:
        :param str user_id: Owner user id
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'x_api_version', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_update_blob" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `document_update_blob`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/UpdateBlob', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_upload(self, **kwargs):  # noqa: E501
        """Upload multiple documents  # noqa: E501

        This operation uploads documents to the AIForged server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_upload(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[object] data:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param str user_id: The user ID
        :param int project_id: The project ID
        :param int class_id: The cass ID
        :param AIForgedDALDocumentStatus status: The status of document to upload
        :param AIForgedDALUsageType usage: The usage of the document to upload
        :param int masterid: The parent document iD
        :param str comment: Comments to be added to the document
        :param str external_id: The external ID of the document
        :param str result: Result data to be added to the document
        :param str result_id: The result ID
        :param int result_index: The result index
        :param str guid: A guid ID
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_upload_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_upload_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_upload_with_http_info(self, **kwargs):  # noqa: E501
        """Upload multiple documents  # noqa: E501

        This operation uploads documents to the AIForged server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_upload_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[object] data:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param str user_id: The user ID
        :param int project_id: The project ID
        :param int class_id: The cass ID
        :param AIForgedDALDocumentStatus status: The status of document to upload
        :param AIForgedDALUsageType usage: The usage of the document to upload
        :param int masterid: The parent document iD
        :param str comment: Comments to be added to the document
        :param str external_id: The external ID of the document
        :param str result: Result data to be added to the document
        :param str result_id: The result ID
        :param int result_index: The result index
        :param str guid: A guid ID
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['data', 'x_api_version', 'stpd_id', 'user_id', 'project_id', 'class_id', 'status', 'usage', 'masterid', 'comment', 'external_id', 'result', 'result_id', 'result_index', 'guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_upload" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'class_id' in params:
            query_params.append(('classId', params['class_id']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'guid' in params:
            query_params.append(('guid', params['guid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'data' in params:
            form_params.append(('data', params['data']))  # noqa: E501
            collection_formats['data'] = 'multi'  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/Upload', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def document_upload_file(self, **kwargs):  # noqa: E501
        """Upload a document  # noqa: E501

        This operation uploads a document to the AIForged server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_upload_file(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param str user_id: The user ID
        :param int project_id: The project ID
        :param int class_id: The cass ID
        :param AIForgedDALDocumentStatus status: The status of document to upload
        :param AIForgedDALUsageType usage: The usage of the document to upload
        :param int masterid: The parent document ID. Optional
        :param str comment: Comments to be added to the document
        :param str external_id: The external ID of the document
        :param str result: Result data to be added to the document
        :param str result_id: The result ID
        :param int result_index: The result index
        :param str guid: A guid ID
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.document_upload_file_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.document_upload_file_with_http_info(**kwargs)  # noqa: E501
            return data

    def document_upload_file_with_http_info(self, **kwargs):  # noqa: E501
        """Upload a document  # noqa: E501

        This operation uploads a document to the AIForged server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.document_upload_file_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file:
        :param str x_api_version:
        :param int stpd_id: The service ID
        :param str user_id: The user ID
        :param int project_id: The project ID
        :param int class_id: The cass ID
        :param AIForgedDALDocumentStatus status: The status of document to upload
        :param AIForgedDALUsageType usage: The usage of the document to upload
        :param int masterid: The parent document ID. Optional
        :param str comment: Comments to be added to the document
        :param str external_id: The external ID of the document
        :param str result: Result data to be added to the document
        :param str result_id: The result ID
        :param int result_index: The result index
        :param str guid: A guid ID
        :return: list[AIForgedViewModelsDocumentViewModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'x_api_version', 'stpd_id', 'user_id', 'project_id', 'class_id', 'status', 'usage', 'masterid', 'comment', 'external_id', 'result', 'result_id', 'result_index', 'guid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method document_upload_file" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'stpd_id' in params:
            query_params.append(('stpdId', params['stpd_id']))  # noqa: E501
        if 'user_id' in params:
            query_params.append(('userId', params['user_id']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('projectId', params['project_id']))  # noqa: E501
        if 'class_id' in params:
            query_params.append(('classId', params['class_id']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'usage' in params:
            query_params.append(('usage', params['usage']))  # noqa: E501
        if 'masterid' in params:
            query_params.append(('masterid', params['masterid']))  # noqa: E501
        if 'comment' in params:
            query_params.append(('comment', params['comment']))  # noqa: E501
        if 'external_id' in params:
            query_params.append(('externalId', params['external_id']))  # noqa: E501
        if 'result' in params:
            query_params.append(('result', params['result']))  # noqa: E501
        if 'result_id' in params:
            query_params.append(('resultId', params['result_id']))  # noqa: E501
        if 'result_index' in params:
            query_params.append(('resultIndex', params['result_index']))  # noqa: E501
        if 'guid' in params:
            query_params.append(('guid', params['guid']))  # noqa: E501

        header_params = {}
        if 'x_api_version' in params:
            header_params['X-Api-Version'] = params['x_api_version']  # noqa: E501

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/api/Document/UploadFile', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AIForgedViewModelsDocumentViewModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
