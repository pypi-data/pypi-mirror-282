"""
**Abstract validator (validation of input values)**

A validator capable of validating some object (``obj``) by applying one or more
validation strategies (``methods``) to it. Validation can be performed by
calling the validation method for an instance of a class, as well as through
a decorator with parameters
"""

__authors__ = ["Maxim Ustin"]
__contact__ = "mxustin@gmail.com"
__copyright__ = "Copyright © 2024, Maxim Ustin"
__credits__ = ["Maxim Ustin"]
__date__ = "2024"
__deprecated__ = False
__email__ =  "mxustin@gmail.com"
__license__ = "MIT License"
__maintainer__ = "Maxim Ustin"
__status__ = "Beta"
__version__ = "0.0.1"

from ast import Raise, parse, walk
from functools import wraps
from inspect import Signature, getsource, signature
from re import search
from typing import Any, Callable, Dict, List, Optional, Tuple, TypeAlias
from typing import TypeVar

VObj: TypeAlias = Any
"""
**The object being checked**

An alias for the validated object (the verification object). The object must 
There will always be only one
"""

Args: TypeAlias = Tuple
"""
**Arguments**

An alias for the tuple of arguments
"""

KWArgs: TypeAlias = Dict[str, Any]
"""
**Named arguments**

Alias of the dictionary of named arguments
"""

VParams: TypeAlias = Optional[KWArgs]
"""
**Validation parameters (optional)**

The alias of an optional parameter in the form of named arguments
"""

VMethod: TypeAlias = Callable[[VObj, VParams], None]
"""
**Verification method (callable)**

An alias for a specific validation method that is passed to the validator. 
This method should not return anything, it should not contain anything inside 
itself exception
"""

VMethods: TypeAlias = List[VMethod]
"""
**List of verification methods**

An alias for the list of all methods that are passed to the validator
"""

EHandler: TypeAlias = Optional[Callable[[Exception, VObj], None]]
"""
**Exception handling method (handler)**

An alias for the error handling method that occurred during the application process 
verification methods for the verification object
"""

T = TypeVar('T', bound='Validator')
"""
**Self typing**

Type annotation for self in the `Validator` class
"""


NOT_LIST = (
    'The [methods] parameter must be a list of validation methods ('
    'the actual type of [methods] received is {})'
)

EMPTY_LIST = (
    'The list of methods should not be empty: at least one '
    'verification method is required'
)

NON_CALLABLE_M = (
    'Each element of the methods list must be a method ("callable"). '
    'Instead of an object of type {} has been detected for this'
)

NON_CALLABLE_H = (
    'The handler object must be a method (callable) or None (the actual'
    'type of the received handler is {}'
)

INFO = (
    'Error [💥={}] with message [✉️="{}"]. The handler is not installed ('
    'this message was generated by the validator itself'
)

NOT_ENOUGH_PARAMS = (
    'The resulting method must accept at least two parameters '
)

NOT_RAISES = (
    'The method received as a specific validator must contain '
    'calling an exception, but does not contain any raise calls'
)

PARAM_IS_NOT_EXCEPTION = (
    'The first parameter of the exception handling method must be '
    'Exception, but does not apply to this type'
)

PARAM_IS_NOT_ANY = (
    'The parameter must be of type Any, but does not belong to this type'
)

RET_NOT_NONE = (
    'The received method contains the return value, while it does not '
    'must return nothing'
)

PARAM_IS_NOT_DICT = (
    'The parameter must be of the Dict type, but does not belong to this type'
)

ONE_PARAM_REQUIRED = (
    'The resulting method must accept at least one parameter'
)

UNKNOWN_ERR = (
    'An unexpected error has occurred'
)

NO_OBJ = (
    'Failed to get the verification object'
)


class ValError(Exception):
    """
    **Base class "Validation error"**

    Base class for validation exceptions (used for "Abstract Validator")
    """

    # No implementation required


class AVal:
    """
    **Base class "Abstract Validator"**

    A validator capable of looping through a list of verification methods
    (``methods``) in relation to the verification
    object (``obj``), raising the appropriate
    exceptions in case of failures
    """

    def __init__(self: T, methods: VMethods, handler: EHandler = None) -> None:
        """
        **Instance initialization**

        Initialization and installation of verification and error handling
        methods

        :param methods: list of verification methods
        :param handler: error handler
        :return: ``None``
        """
        self._methods = []
        self._handler = None

        if not isinstance(methods, list):
            tpe = type(methods)
            raise TypeError(NOT_LIST.format(tpe))

        if not methods:
            raise TypeError(EMPTY_LIST)

        for method in methods:
            self._set_method(method)

        if handler is not None and not callable(handler):
            tpe = type(handler)
            raise TypeError(NON_CALLABLE_H.format(tpe))

        if handler:
            self._set_handler(handler)

    def validate(self: T, obj: VObj, **params: VParams) -> VObj:
        """
        **Validation method**

        Validation is being performed (in case of verification failure, it will
        be raised the corresponding exception is called and the handler
        is called)

        :param obj: validation object
        :param params: validation parameters
        :return: validation object (unchanged)
        """

        def er_name(error_class: type[ValError]) -> str | None:
            """
            **Method for getting the error name**

            Allows you to get a "clean" error type name from
            the string that type returns

            :param error_class: the result of the type(ERROR) function
            :return: a string containing the "clean" name of the error
                     (for example, TypeError) or nothing
            """
            pattern = r'<class \'__main__\.(.*?)\'>'
            match = search(pattern, str(error_class))
            return match.group(1) if match else None

        for method in self._methods:
            try:
                method(obj, params)

            except ValError as er:
                if self._handler is None:
                    en = er_name(type(er))
                    msg = er.args[0]
                    # print(INFO.format(en, msg))
                    raise ValError(INFO.format(en, msg))
                else:
                    self._handler(er, obj)

            except Exception:
                raise Exception(UNKNOWN_ERR)

        return obj

    def validate_with(self: T, **params: VParams) -> Callable:
        """
        ** Decorator **

        Decorator (with parameters in the form of named arguments)

        :param params: arguments required for validation
        :return: a specific validation function
        """

        def decorator(func: Callable) -> Callable:
            @wraps(func)
            def wrapper(*args: Any, **kwargs: Any) -> Any:            # noqa
                if args:
                    if len(args) == 1:
                        obj = args[0]
                    else:
                        obj = args[1]
                else:
                    obj = kwargs.pop('obj', None)

                if obj:
                    self.validate(obj, **params)
                else:
                    raise ValueError(NO_OBJ)

                return func(*args, **kwargs)
            return wrapper
        return decorator

    def _set_method(self: T, method: VMethod) -> None:
        """
        **Setting values for specific validation methods**

        We check each received specific validation method and add it to
        list. Checks are carried out on the subject of:
         - is it called (should be);
         - does not have a return value (should not);
         - whether the call contains an exception inside (should).

        :param method: a separate specific validation method for verification
        :return: ``None``
        """
        if not callable(method):
            tpe = type(method)
            raise TypeError(NON_CALLABLE_M.format(tpe))

        sign = signature(method)
        ra = sign.return_annotation

        if ra is not Signature.empty and ra is not None:
            raise TypeError(RET_NOT_NONE)

        params = list(sign.parameters.values())

        if len(params) < 1:
            raise TypeError(NOT_ENOUGH_PARAMS)

        first_param = params[0] if params[0].name != 'self' else params[1]

        if first_param.annotation != Any:
            raise TypeError(PARAM_IS_NOT_ANY)

        method_source = getsource(method)
        sem_tree = parse(method_source)
        contains_exception = False

        for node in walk(sem_tree):
            if isinstance(node, Raise):
                contains_exception = True
                break

        if not contains_exception:
            raise TypeError(NOT_RAISES)

        self._methods.append(method)

    def _set_handler(self: T, handler: EHandler) -> None:
        """
        **Setting the exception handling method**

        We check the received method (here we already know for sure that it has
        been received), and we install it. Checks are carried out on the
        subject of:
         - are there two (or more) parameters;
         - is the first parameter an exception;
         - whether the second parameter is Any.

        :param handler: method for handling exceptional situations
        :return:
        """
        sign = signature(handler)
        params = list(sign.parameters.values())

        ra = sign.return_annotation

        if ra is not Signature.empty and ra is not None:
            raise TypeError(RET_NOT_NONE)

        if len(params) < 2:
            raise TypeError(NOT_ENOUGH_PARAMS)

        first_param = params[0] if params[0].name != 'self' else params[1]

        if first_param.annotation != Exception:
            raise TypeError(PARAM_IS_NOT_EXCEPTION)

        second_param = params[1] if params[0].name != 'self' else params[2]

        if second_param.annotation != Any:
            raise TypeError(PARAM_IS_NOT_ANY)

        self._handler = handler
