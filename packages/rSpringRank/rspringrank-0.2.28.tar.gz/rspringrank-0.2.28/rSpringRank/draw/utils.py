from collections import defaultdict

import distinctipy
import numpy as np
from sklearn.neighbors import NearestNeighbors


def reverse_dict(input_dict):
    reversed_dict = defaultdict(list)
    for key, value in input_dict.items():
        reversed_dict[value].append(key)
    return dict(reversed_dict)


def determine_optimal_epsilon(arr, min_samples=2):
    """
    Determines the optimal epsilon value for clustering using the k-distance graph method.

    Parameters:
    arr (np.ndarray): The input array of float values.
    min_samples (int): The number of nearest neighbors to consider.

    Returns:
    float: The optimal epsilon value.
    """
    # Reshape the array for NearestNeighbors
    arr = arr.reshape(-1, 1)

    # Compute the nearest neighbors
    neighbors = NearestNeighbors(n_neighbors=min_samples)
    neighbors_fit = neighbors.fit(arr)
    distances, indices = neighbors_fit.kneighbors(arr)

    # Sort the distances to the nearest neighbors
    distances = np.sort(distances[:, 1], axis=0)

    # Find the point of maximum curvature (elbow)
    diff = np.diff(distances)
    optimal_index = np.argmax(diff)
    optimal_epsilon = distances[optimal_index]

    return optimal_epsilon


def cluster_1d_array(arr, min_samples=2):
    """
    Clusters a 1D array of float values such that adjacent values are grouped together.

    Parameters:
    arr (list or np.ndarray): The input array of float values.
    min_samples (int): The number of nearest neighbors to consider for determining epsilon.

    Returns:
    tuple: A tuple containing a list of clusters and a dictionary mapping each index of the input array to the index of the identified cluster.
    """
    if not isinstance(arr, np.ndarray):
        arr = np.array(arr)

    # Determine the optimal epsilon value
    eps = determine_optimal_epsilon(arr, min_samples)

    # Sort the array and keep track of original indices
    sorted_indices = np.argsort(arr)
    sorted_arr = arr[sorted_indices]

    # Initialize clusters and index mapping
    clusters = []
    index_mapping = {}
    current_cluster = [sorted_arr[0]]
    current_cluster_index = 0

    # Iterate through the sorted array and form clusters
    for i in range(1, len(sorted_arr)):
        if sorted_arr[i] - sorted_arr[i - 1] <= eps:
            current_cluster.append(sorted_arr[i])
        else:
            clusters.append(current_cluster)
            for idx in sorted_indices[i - len(current_cluster) : i]:
                index_mapping[idx] = current_cluster_index
            current_cluster = [sorted_arr[i]]
            current_cluster_index += 1

    # Append the last cluster
    clusters.append(current_cluster)
    for idx in sorted_indices[len(sorted_arr) - len(current_cluster) :]:
        index_mapping[idx] = current_cluster_index

    # Sort clusters by their mean values in descending order
    cluster_means = [np.mean(cluster) for cluster in clusters]
    sorted_cluster_indices = np.argsort(cluster_means)[::-1]
    sorted_clusters = [clusters[i] for i in sorted_cluster_indices]

    # Update index_mapping according to the new cluster order
    new_index_mapping = {}
    for new_cluster_index, original_cluster_index in enumerate(sorted_cluster_indices):
        for idx in index_mapping:
            if index_mapping[idx] == original_cluster_index:
                new_index_mapping[idx] = new_cluster_index

    return sorted_clusters, new_index_mapping


def rgb_to_hex(rgb_color):
    """Convert RGB tuple to hex color. Generated by GPT-4 OMNI."""
    return "#{:02x}{:02x}{:02x}".format(
        int(rgb_color[0] * 255), int(rgb_color[1] * 255), int(rgb_color[2] * 255)
    )


def generate_complementary_colors(k):
    """
    Generate a list of k visually distinct complementary colors.
    Generated by GPT-4 OMNI.

    Parameters:
    k (int): Number of complementary colors to generate.

    Returns:
    List[str]: List of hex color codes.
    """
    # Generate k visually distinct colors
    colors = distinctipy.get_colors(k, pastel_factor=0.9)

    # Convert the RGB tuples to hex color codes
    hex_colors = [rgb_to_hex(color) for color in colors]

    return hex_colors
